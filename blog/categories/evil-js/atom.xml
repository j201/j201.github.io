<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Evil-JS | j201's Meanderings]]></title>
  <link href="http://j201.github.io/blog/categories/evil-js/atom.xml" rel="self"/>
  <link href="http://j201.github.io/"/>
  <updated>2014-05-15T21:30:55-04:00</updated>
  <id>http://j201.github.io/</id>
  <author>
    <name><![CDATA[j201]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Evil JS: With Considered Somewhat Useful]]></title>
    <link href="http://j201.github.io/blog/2013/08/03/evil-js-with-considered-somewhat-useful/"/>
    <updated>2013-08-03T12:16:00-04:00</updated>
    <id>http://j201.github.io/blog/2013/08/03/evil-js-with-considered-somewhat-useful</id>
    <content type="html"><![CDATA[<p><em>Note: Do not try this at work. It&rsquo;s not that bad but your coworkers and Douglas Crockford might get cross.</em></p>

<p><code>with</code> statements are a little-used, oft-reviled, and underappreciated part of JavaScript. Basically, they allow you to write a statement, often a block, with the properties of a given object added to the scope. Here&rsquo;s an example:</p>

<p>``` javascript
var x = Math.cos(3/2 * Math.PI);</p>

<p>with(Math) {</p>

<pre><code>var y = cos(3/2 * PI);
</code></pre>

<p>}</p>

<p>x; // -1
y; // -1
```</p>

<p>The thing is, <code>with</code> statements are almost universally renounced in the JavaScript community. For example, you can read Douglas Crockford&rsquo;s attack on <code>with</code> from 2006 <a href="http://yuiblog.com/blog/2006/04/11/with-statement-considered-harmful/">here</a>. First of all, <code>with</code> can slow code down by making it difficult for the engine to know what variable is being referred to. But the main problem with <code>with</code> is that it complicates JS&rsquo;s notion of scope. Without <code>with</code>, the variables available in a scope are all of the global variables plus any variables made in local scopes using <code>var</code> or <code>function</code> statements. All of these variables can be both accessed and modified. But using <code>with</code> adds variables to the local scope that were not declared with a <code>var</code> or <code>function</code> statement and shadow those that were. Here&rsquo;s an example of the confusion that can be caused:</p>

<p>``` javascript
var obj = {</p>

<pre><code>a : 1,
b : 2
</code></pre>

<p>};</p>

<p>with (obj) {</p>

<pre><code>a = 3;
var b = 4;
b = 5;
c = 6;
</code></pre>

<p>}
```</p>

<p>Now, what are the values of <code>obj.a</code>, <code>obj.b</code>, <code>obj.c</code>, <code>a</code>, <code>b</code>, and <code>c</code>? ANSWER: <span class="spoiler"><code>obj</code> is <code>{a : 3, b : 5}</code>, <code>a</code> isn&rsquo;t defined, <code>b</code> is 4, and <code>c</code> is 6.</span></p>

<p>So there are good reasons to avoid <code>with</code>. In fact, ES5&rsquo;s strict mode prohibits its use. But the level of hatred and fear directed at it isn&rsquo;t proportional to its flaws and ignores the legitimate uses of with, which I&rsquo;ll cover now.</p>

<h3>Libraries and Modules</h3>

<p>To use a library in JS, one generally has to constantly refer to its object when using its functions, for example using <code>jQuery.ajax</code> instead of <code>ajax</code>. This has led JS libraries to adopt short names such as <code>goog</code>, <code>_</code>, or <code>$</code> for somewhat easier typing, but with the costs of poor readability and losing useful short local variable names. Not adding the library functions to the scope is fine for libraries that you aren&rsquo;t using much, but can be inconvenient for libraries you&rsquo;re using heavily, which is why most programming languages provide a way to import the functions of a module into the current scope. Well, JS has one too:</p>

<p>``` javascript
// Returns a random angle in radians from a circle divided into the given number of steps</p>

<p>function randomAngle(steps) {</p>

<pre><code>with(Math) {
    if (!steps)
        return random() * 2 * PI;
    else
        return floor(random() * steps) / steps * 2 * PI;
}
</code></pre>

<p>}</p>

<p>function randomAngle2(steps) {</p>

<pre><code>if (!steps)
    return Math.random() * 2 * Math.PI;
else
    return Math.floor(Math.random() * steps) / steps * 2 * Math.PI;
</code></pre>

<p>}
```</p>

<p>Yes, it&rsquo;s the same <code>Math</code> example. But it shows an important point: <code>with</code> can make dealing with libraries and built-in modules a lot easier. Unfortunately, with current attitudes towards <code>with</code>, we&rsquo;re stuck waiting until ES6 for a (hopefully) accepted way to do this.</p>

<h3>Block Scope</h3>

<p>One oddity that makes JavaScript different from most C-style languages is the lack of block scope. Instead of local variables beings scoped to nearest block they&rsquo;re declared in (delimited by <code>{</code> and <code>}</code>), like in C or Java, JS variables are scoped to the nearest <code>function() {...}</code> in which they are declared. This is mostly fine (and in my opinion, not a problem at all if you use functional array iterators), but can be occasionally problematic.</p>

<p>A common issue in asynchronous JS is using callbacks in a loop:</p>

<p>``` javascript
for (var i = 0; i &lt; 5; i++) {</p>

<pre><code>setTimeout(function() { console.log(i); }, 10);
</code></pre>

<p>}</p>

<p>// From console:
// 5
// 5
// 5
// 5
// 5
```</p>

<p>So, since the <code>for</code> loop finished executing before the callbacks were executed, the value of <code>i</code> is 5 every time.  In other languages, to get around this, you&rsquo;d just add a block-scoped variable for each iteration of the loop. In fact, this can be done right now in Firefox, but won&rsquo;t be standard until ES6 (see Solution 1 below). So, the standard solution is to wrap the whole thing in an <a href="http://en.wikipedia.org/wiki/IIFE">IIFE</a> (see Solution 2) which is widely supported, but adds a lot of visual noise. The other solution, is to use <code>with</code> to emulate a block scope (Solution 3):</p>

<p>``` javascript
// Solution 1 &ndash; Elegant, but not widely supported
for (var i = 0; i &lt; 5; i++) {</p>

<pre><code>let j = i; // A block scoped variable
setTimeout(function() { console.log(j); }, 10);
</code></pre>

<p>}</p>

<p>// Solution 2 &ndash; Idiomatic but ugly
for (var i = 0; i &lt; 5; i++) {</p>

<pre><code>(function(j) {
    setTimeout(function() { console.log(j); }, 10);
})(i);
</code></pre>

<p>}</p>

<p>// Solution 3 &ndash; Widely supported and readable
for (var i = 0; i &lt; 5; i++) {</p>

<pre><code>with ({j : i})
    setTimeout(function() { console.log(j); }, 10);
</code></pre>

<p>}</p>

<p>// From console:
// 0
// 1
// 2
// 3
// 4
```</p>

<p>Basically, <code>with</code> lets you make block scoped variables. In fact, it&rsquo;s very similar to the <code>let</code> blocks that are coming in ES6:</p>

<p>``` javascript
var a;</p>

<p>let (b = 2, c = 3) {</p>

<pre><code>a = b + c;
</code></pre>

<p>}</p>

<p>a; // 5</p>

<p>with ({b : 4, c : 7}) {</p>

<pre><code>a = b + c;
</code></pre>

<p>}</p>

<p>a; // 11
```</p>

<p>So, while function scoped variables are usually adequate, <code>with</code> lets you use block scoping when you need it.</p>

<h3>Summary</h3>

<h4>Pros:</h4>

<ul>
<li><code>with</code> makes it easier to work with libraries and modules.</li>
<li><code>with</code> allows you to clearly emulate block scope.</li>
<li>In general, using <code>with</code> sparingly can make your code easier to read and write.</li>
</ul>


<h4>Cons:</h4>

<ul>
<li>Using <code>with</code> poorly can result in unclear code.</li>
<li><code>with</code> is rejected by most linters and style guides.</li>
<li><code>with</code> can make code slower.</li>
<li>ES5 strict mode forbids the use of <code>with</code>.</li>
</ul>


<h3>Conclusion</h3>

<p>I&rsquo;ve identified two cases where <code>with</code> can make for clearer code and emulate features that exist in most other languages. However, the JS community&rsquo;s aversion to <code>with</code> makes it almost unusable except in personal projects. Fortunately, both of its use cases will be replaced in ES6 by <code>let</code> and <code>import</code>, but for now, many coders are depriving themselves of a useful tool.So, don&rsquo;t use it at work, but if you have some hobby coding where readability is more important than speed, don&rsquo;t be too afraid to use <code>with</code>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Evil JS: Macros]]></title>
    <link href="http://j201.github.io/blog/2013/06/16/evil-js-macros/"/>
    <updated>2013-06-16T14:37:00-04:00</updated>
    <id>http://j201.github.io/blog/2013/06/16/evil-js-macros</id>
    <content type="html"><![CDATA[<p><em>Note: Don&rsquo;t try this at work. This is bad code that shouldn&rsquo;t be used in production.</em></p>

<p>As every JS hacker knows, <code>eval</code> is evil. It&rsquo;s slow, insecure, and generally unnecessary. The same goes for the <code>Function</code> constructor, which can, but shouldn&rsquo;t be used to create functions using strings to specify the arguments and body. But the badness of <code>eval</code> and <code>Function</code> doesn&rsquo;t mean you can&rsquo;t have some fun with them.</p>

<p><code>Function.prototype.toString</code> is a function that returns the source code of the function it&rsquo;s called from. For example,
``` javascript
var add = function(x, y) {</p>

<pre><code>return x + y;
</code></pre>

<p>};</p>

<p>add.toString();
/*
&ldquo;function (x, y) {</p>

<pre><code>return x + y;
</code></pre>

<p>}&ldquo;
*/
```
This is a feature that is mostly used in debugging, but you&rsquo;ll note that since we can get the function as a string, we can modify it and pass it to the Function constructor. This allows us to implement a feature JS has been sorely lacking, C-style macros!</p>

<h3>Simple Replacements</h3>

<p>So the first thing to implement is simple replacements, like #defines without arguments. Let&rsquo;s use an object to represent these definitions:
``` javascript
var defines = {</p>

<pre><code>PI : '3.14159',
E : '2.71828',
GREETING : '"Hello, "'
</code></pre>

<p>};
```</p>

<p>And now we can implement the first version of the JS preprocesser (let&rsquo;s call it the JSPP). It takes a definition object and a function and returns another function with the macro expansion applied:
``` javascript
function getBody(fn) { // Gets the body of a function as a string</p>

<pre><code>fnStr = fn.toString();
return fnStr.slice(fnStr.indexOf('{') + 1, fnStr.lastIndexOf('}'));
</code></pre>

<p>};</p>

<p>function getArgs(fn) { // Gets the arguments of a function as an array of strings</p>

<pre><code>fnStr = fn.toString();
return fnStr.slice(fnStr.indexOf('(') + 1, fnStr.indexOf(')')).split(',').map(function(x) { return x.trim(); });
</code></pre>

<p>}</p>

<p>function JSPP(defines, fn) {</p>

<pre><code>var args = getArgs(fn);

// Do the replacements
var body = Object.keys(defines)
    .reduce(function (text, replacement) {
        // Uses a RegExp to ensure that the macro name has non-word characters on either side
        // Note that macro names should only use \w characters
        return text.replace(RegExp('(\\W+)' + key + '(\\W+)', 'g'), '$1' + defines[key] + '$2');
    }, getBody(fn));

// Use the function constructor to rebuild the function
return Function.apply(null, args.concat(body));
</code></pre>

<p>}
```</p>

<p>Example usage:
``` javascript
var defines = {</p>

<pre><code>PI : '3.14159',
E : '2.71828',
GREETING : '"Hello, "'
</code></pre>

<p>};</p>

<p>var doStuff = JSPP(defines, function(val) {</p>

<pre><code>return typeof val === 'number' ? PI + E * val : GREETING + val;
</code></pre>

<p>});</p>

<p>doStuff(2) // 8.57815
doStuff(&lsquo;Bob&rsquo;) // Hello, Bob
doStuff.toString() // function anonymous(val) { return typeof val === &lsquo;number&rsquo; ? 3.14159 + 2.71828 * val : &ldquo;Hello, &rdquo; + val; }
```</p>

<h3>Function-like Macros</h3>

<p>Okay, let&rsquo;s go one level deeper: macro arguments. We&rsquo;ll use the same syntax as the <code>Function</code> constructor, argument strings followed by body, except in an array:
``` javascript
var defines = {</p>

<pre><code>ABS : ['x', '((x)&lt;0?-(x):(x))']
</code></pre>

<p>};
```</p>

<p>And the new (buggy) JSPP implementation:
``` javascript
function getBody(fn) { // Gets the body of a function as a string</p>

<pre><code>fnStr = fn.toString();
return fnStr.slice(fnStr.indexOf('{') + 1, fnStr.lastIndexOf('}'));
</code></pre>

<p>};</p>

<p>function getArgs(fn) { // Gets the arguments of a function as an array of strings</p>

<pre><code>fnStr = fn.toString();
return fnStr.slice(fnStr.indexOf('(') + 1, fnStr.indexOf(')')).split(',').map(function(x) { return x.trim(); });
</code></pre>

<p>}</p>

<p>function JSPP(defines, fn) {</p>

<pre><code>var args = getArgs(fn);

// Do the replacements
var body = Object.keys(defines)
    .reduce(function (text, key) {
        if (typeof defines[key] === 'string') { // Do a simple replacement
            return text.replace(RegExp('(\\W+)' + key + '(\\W+)', 'g'), '$1' + defines[key] + '$2');
        } else { // Do a replacement with arguments
            // First, convert the arguments into regex replacement patterns, such as $1 or $23
            var macroBody = defines[key][defines[key].length - 1];
            var macroArgs = defines[key].slice(0, -1);
            var replacement = macroArgs.reduce(function(text, arg, index) {
                return text.replace(RegExp(arg, 'g'), '$' + (index + 1));
            }, macroBody);
            // Now, use RegExp capturing to apply the replacement
            // Note that macro names can't have regex metacharacters, macro arguments cannot have commas
            // and will often fail if they have ending parens, and there must be at least one argument.
            // This is a messy, bad, but easy way of doing the replacement,
            // which fits with the theme of the post, I feel.
            return text.replace(RegExp(key + // The macro name
                                       '\\s*\\(\\s*(.+?)' + // The initial paren and first argument
                                       Array(macroArgs.length).join('\\s*,\\s*(.+?)') + // The other args, separated by commas
                                       '\\s*\\)', // The final paren
                                       'g'), replacement);
        }
    }, getBody(fn));
// Use the function constructor to rebuild the function
return Function.apply(null, args.concat(body));
</code></pre>

<p>}
```</p>

<p>Example usage:
``` javascript
var defines = {</p>

<pre><code>PI : '3.14159',
E : '2.71828',
ABS : ['x', '((x)&lt;0?-(x):(x))'],
RESISTORS_PARALLEL : ['a', 'b', '((a)*(b)/((a)+(b)))']
</code></pre>

<p>};</p>

<p>var doStuff = JSPP(defines, function(val) {</p>

<pre><code>return RESISTORS_PARALLEL(PI, E) * ABS(val);
</code></pre>

<p>});</p>

<p>doStuff(2) // 2.9146452959536644
doStuff(-2) // 2.9146452959536644
doStuff.toString()
/*
function anonymous(val) {</p>

<pre><code>return ((3.14159)*(2.71828)/((3.14159)+(2.71828))) * ((val)&lt;0?-(val):(val));
</code></pre>

<p>}
*/
```</p>

<p>So there you go, everyone&rsquo;s favourite preprocesser partially ported to JavaScript! And while this is not a good use of <code>Function</code> and <code>Function.prototype.toString</code>, it does show their power. They both have legitimate purposes, and if you&rsquo;re not afraid to go down that road, you can do some pretty wacky stuff with them.</p>
]]></content>
  </entry>
  
</feed>
