<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8">
		<title>j201&#39;s Blather</title>
		<link href='//fonts.googleapis.com/css?family=Roboto+Slab:400,700' rel='stylesheet' type='text/css'>
		<link href='//fonts.googleapis.com/css?family=Source+Sans+Pro' rel='stylesheet' type='text/css'>
		<link rel="stylesheet" href="/reset.css">
		<link rel="stylesheet" href="/solarized_light.css">
		<link rel="stylesheet" href="/styles.css">
		<link rel="apple-touch-icon" sizes="57x57" href="/apple-touch-icon-57x57.png">
		<link rel="apple-touch-icon" sizes="114x114" href="/apple-touch-icon-114x114.png">
		<link rel="apple-touch-icon" sizes="72x72" href="/apple-touch-icon-72x72.png">
		<link rel="apple-touch-icon" sizes="144x144" href="/apple-touch-icon-144x144.png">
		<link rel="apple-touch-icon" sizes="60x60" href="/apple-touch-icon-60x60.png">
		<link rel="apple-touch-icon" sizes="120x120" href="/apple-touch-icon-120x120.png">
		<link rel="apple-touch-icon" sizes="76x76" href="/apple-touch-icon-76x76.png">
		<link rel="apple-touch-icon" sizes="152x152" href="/apple-touch-icon-152x152.png">
		<link rel="icon" type="image/png" href="/favicon-196x196.png" sizes="196x196">
		<link rel="icon" type="image/png" href="/favicon-160x160.png" sizes="160x160">
		<link rel="icon" type="image/png" href="/favicon-96x96.png" sizes="96x96">
		<link rel="icon" type="image/png" href="/favicon-16x16.png" sizes="16x16">
		<link rel="icon" type="image/png" href="/favicon-32x32.png" sizes="32x32">
		<meta name="msapplication-TileColor" content="#00aba9">
		<meta name="msapplication-TileImage" content="/mstile-144x144.png">
	</head>
	<body>
		<header>
			<div id="title-box"><a href="/" id="over-title">j201's<br>Blather</a></div><nav>
				<div id="top-links">
					<a href="/archives.html">Archives</a>
					<a href="/projects.html">Projects</a>
					<a href="https://github.com/j201">Github</a>
				</div>
			</nav>
		</header>
		<hr id="sidebar-topper">
		<nav id="sidebar">
			<a href="/" id="under-title">j201's<br>Blather</a>
			<a href="/archives.html"><h2 class="sidebar-title">Posts</h2></a>
			<ul id="post-list"><li><a class="post-list-entry" href="/posts/2014-10-12-The-Ultimate-Vim-jk-Binding.html">The Ultimate Vim j&#x2F;k Binding</a></li>
<li><a class="post-list-entry" href="/posts/2014-08-30-TypeScript-The-Bad-Parts.html">TypeScript: The Bad Parts</a></li>
<li><a class="post-list-entry" href="/posts/2014-04-20-Expressing-Yourself.html">Expressing Yourself</a></li>
<li><a class="post-list-entry" href="/posts/2013-09-27-Functional-List-Processing-in-JS.html">Functional List Processing in JS</a></li>
<li><a class="post-list-entry" href="/posts/2013-08-03-Evil-JS-With-Considered-Somewhat-Useful.html">Evil JS: With Considered Somewhat Useful</a></li>
<li><a class="post-list-entry" href="/posts/2013-06-22-JS-Object-Literal-Inheritance.html">JS Object Literal Inheritance</a></li>
<li><a class="post-list-entry" href="/posts/2013-06-16-Evil-JS-Macros.html">Evil JS: Macros</a></li>
<li><a class="post-list-entry" href="/posts/2013-06-15-Hello,-World!.html">Hello, World!</a></li>
</ul>
		</nav><div id="content">
			<div id="content-inner"><div class="post">
	<h2><a href="/posts/2014-10-12-The-Ultimate-Vim-jk-Binding.html">The Ultimate Vim j&#x2F;k Binding</a></h2>
	<br>
	<span class="date-comments">October 12, 2014 | <a href="/posts/2014-10-12-The-Ultimate-Vim-jk-Binding.html#disqus_thread">Comments</a></span>
	<p>As a user of <code>relativenumber</code>, I get a bit more mileage out of <code>j</code> and <code>k</code> than many Vim users. It enables me to quickly see how far away I am from a line, making jumps like <code>28j</code> easy and practical. However, <code>relativenumber</code> works with lines delimited by newline characters, not the lines you see on the screen. And if a line wraps, <code>j</code> and <code>k</code> will move by text lines, not visual lines, causing awkward jumps. Because of this, may users have this in their .vimrcs:</p>
<pre><code><span class="hljs-keyword">nnoremap</span> <span class="hljs-keyword">j</span> gj
<span class="hljs-keyword">nnoremap</span> <span class="hljs-keyword">k</span> gk
</code></pre><p>But, since <code>j</code> and <code>k</code> no longer act on text lines, <code>23j</code> may no longer go the the line marked <code>23</code> in the gutter. If there is a wrapped line between the cursor and the target, it will actually take multiple presses of <code>j</code> to pass that line, meaning that the cursor&#39;s end position will be too high. A good way to get around this would be to have single presses of <code>j</code> and <code>k</code> act as <code>gj</code> and <code>gk</code> while <code>j</code> and <code>k</code> with a count would act normally.</p>
<p>The other issue that bothered me was that large <code>j</code> and <code>k</code> jumps didn&#39;t get added to the jumplist, meaning that there was no easy way to undo and redo them. That can be fixed by automatically setting the <code>&#39;</code> mark if <code>j</code> or <code>k</code> is executed with a count.</p>
<p>So, without further ado, this is what I&#39;ve come up with:</p>
<pre><code><span class="hljs-input"><span class="hljs-prompt">nnoremap &lt;silent&gt;</span> k <span class="hljs-symbol">:&lt;C-U&gt;execute</span> <span class="hljs-string">'normal!'</span> (<span class="hljs-symbol">v:</span>count &gt; <span class="hljs-number">1</span> ? <span class="hljs-string">"m'"</span> . <span class="hljs-symbol">v:</span>count <span class="hljs-symbol">:</span> <span class="hljs-string">'g'</span>) . <span class="hljs-string">'k'</span>&lt;<span class="hljs-constant">CR</span>&gt;
nnoremap &lt;silent&gt; j <span class="hljs-symbol">:&lt;C-U&gt;execute</span> <span class="hljs-string">'normal!'</span> (<span class="hljs-symbol">v:</span>count &gt; <span class="hljs-number">1</span> ? <span class="hljs-string">"m'"</span> . <span class="hljs-symbol">v:</span>count <span class="hljs-symbol">:</span> <span class="hljs-string">'g'</span>) . <span class="hljs-string">'j'</span>&lt;<span class="hljs-constant">CR</span>&gt;</span>
</code></pre><p>This does the following:</p>
<ul>
<li>For an <em>n</em><code>j</code> command, <code>m&#39;nj</code> is instead executed</li>
<li>For a <code>j</code> command without a count, <code>gj</code> is instead executed</li>
</ul>
<p>It&#39;s not perfect - in visual mode, <code>j</code> and <code>k</code> revert to their normal definitions, but I&#39;m really enjoying its more intuitive behaviour in normal mode.</p>

	<hr>
</div>
<div class="post">
	<h2><a href="/posts/2014-08-30-TypeScript-The-Bad-Parts.html">TypeScript: The Bad Parts</a></h2>
	<br>
	<span class="date-comments">August 30, 2014 | <a href="/posts/2014-08-30-TypeScript-The-Bad-Parts.html#disqus_thread">Comments</a></span>
	<p><a href="http://www.typescriptlang.org/">TypeScript</a> is Microsoft&#39;s attempt to bring type checking to the Wild West of JS. It also brings features such as arrow functions and &quot;classes&quot; inspired by ES6 spec drafts. After working with it for a while, I feel it has some nice bits, but on the whole it&#39;s sorely lacking. It seems to be trying to turn JS into C# while ignoring the drawbacks and limitations of that approach. Here I&#39;d like to go through the major features of TypeScript and identify how it got them wrong.</p>
<h3 id="inexpressive-types">Inexpressive Types</h3>
<p>Despite having structural types (yay!), TS has a remarkably inflexible type system. It&#39;s lacking many powerful features that are common in modern structural type systems, which reduces its ability to model and verify programs. However, TypeScript has an even greater requirement in that it must be able to describe the types of existing JS code, which includes functions that wouldn&#39;t be allowed in many strongly typed languages. Even though this is difficult, TS falls short.</p>
<h4 id="union-types">Union Types</h4>
<p>The feature I find the most lacking is union types: where a value can be considered to be one of two types. This is so common in JS that I can&#39;t understand why TypeScript wouldn&#39;t include it. Sure, you can implement an <code>Either&lt;TLeft, TRight&gt;</code> type in TS, but the lack of native support forces the use of <code>any</code> <a href="https://github.com/borisyankov/DefinitelyTyped/blob/9d88dadf44aaedcabde88053342617575a851f39/easeljs/easeljs.d.ts#L100">in</a> <a href="https://github.com/borisyankov/DefinitelyTyped/blob/52b37e40fa69c6a57b09578305827294a7c24f36/iscroll/iscroll-5.d.ts#L38">many</a> <a href="https://github.com/borisyankov/DefinitelyTyped/blob/dd35f69637817e3f7f8fb23b8d4b033885ad32cd/fancybox/fancybox.d.ts#L100">cases</a>, which removes type verification. One of the first bugs I had to deal with in TypeScript was caused by an Underscore function that returned a number or a given generic type, but the TypeScript annotation simply said that it returned the generic type (a bug that <a href="https://github.com/borisyankov/DefinitelyTyped/issues/1513">still exists</a>). This problem <a href="https://typescript.codeplex.com/workitem/1364">has been raised</a>, but there doesn&#39;t seem to be any interest from the devs, possibly because it&#39;s a feature that&#39;s alien to languages like C# and Java.</p>
<h4 id="higher-kinded-types">Higher-kinded Types</h4>
<p>Consider the following interfaces:</p>
<pre><code class="lang-typescript"><span class="hljs-interface"><span class="hljs-keyword">interface</span> Orderable&lt;Coll&lt;T&gt;&gt; </span>{
    sortBy: (comparator: (a: T, b: T) =&gt; <span class="hljs-built_in">number</span>) =&gt; Coll&lt;T&gt;;
}

<span class="hljs-interface"><span class="hljs-keyword">interface</span> Mappable&lt;Box&lt;T&gt;&gt; </span>{
    map: <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">U</span>&gt;</span>(f: (el: T) =&gt; U) =&gt; Box<span class="hljs-tag">&lt;<span class="hljs-title">U</span>&gt;</span>;</span>
}
</code></pre>
<p>(Those familiar with functors will recognize the second one, but I&#39;m calling it Mappable to keep things accessible.)</p>
<p>These are pretty clear and useful types. They represent, respectively, collections that can be sorted to return the same kind of collection and types that contain a value that can be transformed with a function. You can then use them in less abstract types:</p>
<pre><code class="lang-typescript"><span class="hljs-interface"><span class="hljs-keyword">interface</span> Sequence&lt;T&gt; extends Mappable&lt;Sequence&lt;T&gt;&gt; </span>{
    first: () =&gt; T;
    rest: () =&gt; Sequence&lt;T&gt;;
    cons: (t: T) =&gt; Sequence&lt;T&gt;;
    empty: () =&gt; <span class="hljs-built_in">boolean</span>;
    <span class="hljs-comment">// Automatically derives:</span>
    <span class="hljs-comment">// map&lt;U&gt;(f: (el: T) =&gt; U): Sequence&lt;U&gt;;</span>
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">list</span>&lt;<span class="hljs-title">T</span>&gt;<span class="hljs-params">()</span>: <span class="hljs-title">Sequence</span>&lt;<span class="hljs-title">T</span>&gt; </span>{
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">cons</span><span class="hljs-params">(e: T, l: Sequence&lt;T&gt;)</span>: <span class="hljs-title">Sequence</span>&lt;<span class="hljs-title">T</span>&gt; </span>{
        <span class="hljs-keyword">var</span> me = {
            first: () =&gt; e,
            rest: () =&gt; l,
            empty: () =&gt; <span class="hljs-literal">false</span>,
            map: <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">U</span>&gt;</span>(f: (el: T) =&gt; U) =&gt; l.map(f).cons(f(e)),
            cons: v =&gt; cons(v, me)
        };
        return me;
    }

    var empty: Sequence<span class="hljs-tag">&lt;<span class="hljs-title">T</span>&gt;</span> = {
        first: () =&gt; null,
        rest: () =&gt; empty,
        map: () =&gt; empty,
        empty: () =&gt; true,
        cons: v =&gt; cons(v, empty)
    };

    return empty;
}</span>
</code></pre>
<p>So our sequence type just extended Mappable and automatically got a definition for a map function that takes a <code>T =&gt; U</code> function and returns a <code>Sequence&lt;U&gt;</code>. This is nice for concisenesss and it enables us to write functions that can take any <code>Mappable</code> or a similar type and handle them without having to know the underlying implementation. There&#39;s just one problem: TypeScript can&#39;t do this. More specifically, it doesn&#39;t allow nested generics like <code>Mappable&lt;Box&lt;T&gt;&gt;</code>, where <code>Box</code> and <code>T</code>    aren&#39;t known by <code>Mappable</code>. Instead, we must write <code>Mappable&lt;T&gt;</code> where the type signature of <code>map&lt;U&gt;</code> is <code>(f: (t: T) =&gt; U) =&gt; Mappable&lt;U&gt;</code>. That means that something extending <code>Mappable</code> doesn&#39;t have to return the same <code>Box</code> type. For example, our sequence&#39;s map function could return a promise, an <code>Either</code>, a tree, or any other value as long as it implemented <code>Mappable</code>. Also, the expression <code>l.map(f).cons(f(e))</code> would cause a type error because TS wouldn&#39;t know that <code>l.map(f)</code> returns a sequence rather than an unspecified <code>Mappable</code>. This a violation of type safety, a failure to represent <code>map</code> generically, and, more importantly, it prevents us from encoding useful abstractions like Mappable.</p>
<h4 id="failure-to-model-js-values">Failure to Model JS Values</h4>
<p>In practice, TS types often can&#39;t represent JS values. There are just too many kinds of data and functions that are commonly used in JS for TS&#39;s limited type system to handle. One example is using arrays as <a href="http://msdn.microsoft.com/en-us/library/dd233200.aspx">tuples</a>, which are generally implemented in typed language as sequences with a specified number of elements, each with its own type. Again, TypeScript has no support at all, making it impossible to correctly model JS code that uses them.</p>
<p>On the whole, you can look through the TS typings for <a href="https://github.com/borisyankov/DefinitelyTyped/blob/master/jquery/jquery.d.ts">just about any JS library</a> and tell how bad a job it does by the sheer number of <code>any</code>s in places where the actual type is well-defined but inexpressible by TS&#39;s poor type system.</p>
<p>(If you want to see a type system with a similar goal to TypeScript that does it a lot better, look at Clojure&#39;s <a href="https://github.com/clojure/core.typed/wiki">core.typed</a>.)</p>
<h3 id="faulty-type-system">Faulty Type System</h3>
<p>And, despite adding a type system for correctness, TypeScript fails to eliminate what&#39;s probably the most common error that a type system could fix: <code>TypeError: &lt;thing&gt; is undefined</code>. This is because TypeScript does have one kind of union type: every type is actually a union of that type, <code>null</code>, and <code>undefined</code>. So I can write the following code:</p>
<pre><code class="lang-typescript"><span class="hljs-keyword">var</span> x: <span class="hljs-built_in">number</span> = <span class="hljs-literal">null</span>;
<span class="hljs-built_in">console</span>.log(x.toString());
</code></pre>
<p>And TypeScript won&#39;t bat an eyelid. In any real JS program, this represents a huge class of errors that will go unchecked. And it doesn&#39;t have to be this way; many modern typed languages require you to deal with nil values in a type-safe manner, as they should (Haskell, F#, Rust, OCaml, etc.). Again, this seems to be caused by the unfortunate influence of Java/C# and really reduces the practical benefit of TS.</p>
<h3 id="annoying-type-syntax">Annoying Type Syntax</h3>
<h4 id="functions">Functions</h4>
<p>Function type signatures should be pretty simple, right? You just need something like <code>(number, string) =&gt; string</code>, maybe with corresponding syntax for rest and optional parameters. Well, unfortunately, TS overcomplicates this. First of all, function parameters need to be named in the type, not just in the function literal. Not only is this unusual and redundant, it often leads to devs writing things like <code>(n: number, s:string) =&gt; string</code> and creating useless noise. </p>
<p>The other bizarreness is that there are three different ways to define a function type, but you can&#39;t always use all three, depending on context. </p>
<pre><code><span class="hljs-attribute">map</span>: &lt;U&gt;<span class="hljs-function"><span class="hljs-params">(f: (el: T) =&gt; U)</span> =&gt;</span> Box&lt;U&gt;;
map&lt;U&gt;<span class="hljs-function"><span class="hljs-params">(f: (el: T) =&gt; U)</span>: <span class="hljs-title">Box</span>&lt;<span class="hljs-title">U</span>&gt;;
<span class="hljs-title">map</span>: {&lt;<span class="hljs-title">U</span>&gt;<span class="hljs-params">(f: (el: T) =&gt; U)</span>: <span class="hljs-title">Box</span>&lt;<span class="hljs-title">U</span>&gt;};</span>
</code></pre><p>So, TypeScript function typing is far more complex than it needs to be.</p>
<h4 id="no-type-aliases">No Type Aliases</h4>
<p>When you&#39;re working with a structural type system, the names you give types don&#39;t actually matter, since type compatibility is determined by the structure of the types. So, if you have something like this:</p>
<pre><code class="lang-typescript"><span class="hljs-interface"><span class="hljs-keyword">interface</span> Foo </span>{
    a: <span class="hljs-built_in">number</span>;
    b: <span class="hljs-built_in">string</span>;
}
</code></pre>
<p>You&#39;re just declaring the name <code>Foo</code> to be equivalent to <code>{a: number; b: string;}</code>. So it would make sense to have a syntax like <code>type Foo = {a: number; b: string;};</code>. However, TypeScript went with a C#-ey interface syntax, which only allows type aliases for objects. So, there&#39;s no equivalent for these:</p>
<pre><code class="lang-typescript">type OscillatorType = <span class="hljs-built_in">string</span>;
type Deck = Set&lt;Card&gt;;
type Comparator&lt;T&gt; = (a: T, b: T) =&gt; <span class="hljs-built_in">number</span>;
</code></pre>
<p>(Actually you can do the last one using <code>interface</code>, but the syntax is clunky and weird.)</p>
<p>So aside from being more complex and less flexible than something like <code>type</code>, <code>interface</code> is far less intuitive. It&#39;s as if TypeScript is in denial about using structural types.</p>
<h4 id="clunky-intersection-types">Clunky Intersection Types</h4>
<p>A similar concept to union types are intersection types: where you specify that a value must satisfy two types. So, for example, if you have an argument to a function that must be a Thenable and a Runnable, you could ideally do something like <code>param: Thenable &amp; Runnable</code>. You can do this in TS, but it&#39;s messy because it uses interfaces (which are clearly pretty overburdened):</p>
<pre><code class="lang-typescript"><span class="hljs-comment">// Declare intersection type</span>
<span class="hljs-interface"><span class="hljs-keyword">interface</span> ThenableRunnable extends Thenable, Runnable </span>{}

<span class="hljs-comment">// Only now can we use it</span>
<span class="hljs-keyword">var</span> myFn : (param: ThenableRunnable) =&gt; Thenable;
</code></pre>
<h3 id="-classes-">&quot;Classes&quot;</h3>
<p>The other main change that TypeScript makes is that it adds &quot;classes&quot; to JS. I&#39;m using quotes because it doesn&#39;t actually add any new semantics: a TS class is equivalent to a JS constructor. It adds some sugar to make it look Java/C#-ey, but ultimately it&#39;s still just functions and prototypical objects.</p>
<p>First of all, classes are the last feature I think should be added to JS. When we have higher order functions, we can construct much more powerful abstractions (see SICP/HTDP for this approach) rather than taking the messy, inflexible set of additions to C-ish structs that classes are. I understand that this is an argument I wouldn&#39;t win with many people, so I&#39;m not going to go into depth, but <a href="http://raganwald.com/2014/03/31/class-hierarchies-dont-do-that.html">this post</a> explains well why JS shouldn&#39;t have classes.</p>
<p>Secondly, this leads you into the minefield that is <code>this</code>. Rather than <code>this</code> being bound like it is in Java/C#, it&#39;s generlly determined by the object the function is called from. This works to a certain extent when using prototypical inheritance, but in practice it leads to non-composable and unpredictable functions, as well as silliness like <code>Function.prototype.call.bind(Array.prototype.slice)</code>. It&#39;s not hard to avoid <code>this</code>, but TypeScript uses it enthusiastically in classes. That&#39;s further complicated by the fact that arrow functions have lexical <code>this</code> (it&#39;s the instance of the class that they&#39;re defined in, not the object they&#39;re called on), while method-like functions and regular functions have JS&#39;s normal dynamic <code>this</code>. So this kind of messiness is a clear example of why classes don&#39;t translate well to JS.</p>
<p>And lastly, classes complect type definitions with behaviour. I&#39;m fine with them having inferred types, but often, in TypeScript code, one ends up being pushed into using classes in order to get the types of objects being easily shared between modules. Using interfaces or inference instead in non-classical code often results in longer code for defining types and having to use arcane features like ambient modules and TS&#39;s <code>typeof</code>. You shouldn&#39;t have to use a bad construct like classes in order to get convenient cross-module object typing.</p>
<h3 id="does-it-solve-the-problems-of-js-">Does It Solve the Problems of JS?</h3>
<p>So the recurring theme here is that the TS developers have repeatedly chosen C#-ey approaches over more useful ones (I assume C# since it&#39;s a Microsoft effort, but they could be aiming for Java-ey too). Whether or not you think this is a good goal is a matter of opinion, but I hope I&#39;ve shown here that in practice, it integrates poorly with JS. In particular, a C#-ey type system proves to be very limited in modelling JS values and adding type safety.</p>
<p>So, if you consider lack of type safety to be JS&#39;s largest deficiency, TypeScript isn&#39;t an adequate solution. If you want ES6 features, TypeScript isn&#39;t an adequate solution, since it only has a few of them. And if you want classes like C# (ugh), then TypeScript isn&#39;t an adequate solution, since its classes are a thin film of sugar over totally different semantics. It only really works if you want a half-assed implementation of all three.</p>
<p>What I&#39;d like to see instead is something like <a href="http://typedclojure.org">clojure.core.typed</a> for JS. That is, something that only provides type annotation and type checking but that is designed to accomodate the way the language is written and therefore allows a far wider range of types. Not being based on a C#-ey type system would also allow the inclusion of more powerful type features such as higher-kinded types. Note that such a checker could use special comments for annotations, meaning that it could work with normal JS files. In short, a type checker that does one thing and does it well.</p>

	<hr>
</div>
<div class="post">
	<h2><a href="/posts/2014-04-20-Expressing-Yourself.html">Expressing Yourself</a></h2>
	<br>
	<span class="date-comments">April 20, 2014 | <a href="/posts/2014-04-20-Expressing-Yourself.html#disqus_thread">Comments</a></span>
	<p>The concept of &#39;expressiveness&#39; is one that appears a lot in programming language debates. Broadly speaking, it means the ease with which a language can express ideas. This is often taken to mean whether the language express common constructs prettily and tersely. But I feel that this isn&#39;t the whole story. For example, I&#39;m not a fan of &#39;expressive&#39; syntactical constructs like list comprehensions. Sure, they can express some common list operations in a readable manner, but they&#39;re inherently limited to the features supported by the syntax. Once you want to do an operation that isn&#39;t part of the list comprehension syntax, you have to fall back on the primitive constructs of the language, and you&#39;d better hope that they don&#39;t uglify the whole thing. I feel that an expressive language should go further.</p>
<p>In particular, it bothers me to see people gushing about how the new Python-ish features of ES6 such as <code>for..of</code>, list comprehensions, and classes will finally make JS expressive. I disagree for a few reasons:</p>
<ul>
<li>Expressive programming is an approach to programming, not a characteristic of the language</li>
<li>This approach is already possible and easy in JS</li>
<li>Whether a language can be used expressively is far more determined by its powerful generic features, such as first-class functions and metaprogramming, than problem-specific syntactical constructs, like list comprehensions</li>
</ul>
<p>Instead, I would contend that expressive programming is about writing operations in a way that closely resembles a simple abstract description of each operation, using as few unimportant programming concerns as possible, and that this can be accomplished without highly specialized syntactical constructs.</p>
<p>I&#39;ll show some code to explain. A simple example of a non-expressive construct is the for loop. For example, it&#39;s commonly used to do a thing for each element of an array:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) {
    <span class="hljs-comment">// Do stuff with arr[i]</span>
}
</code></pre>
<p>Conceptually, we want to just do something for each element of an array, but the for loop forces us to deal instead with handling an index variable and using it. This is an example of <a href="http://en.wikipedia.org/wiki/Accidental_complexity">incidental complexity</a>: it&#39;s an implementation detail we don&#39;t care about and that gets in the way of expressing the idea we want to express. A more expressive formulation would be the following:</p>
<pre><code class="lang-javascript">forEach(arr, el =&gt; {
    <span class="hljs-comment">// Do stuff with el</span>
});
</code></pre>
<p>You&#39;ll note that this is very close to our original statement of the problem: <em>do a thing for each element of an array</em>, just with the words rearranged. It&#39;s way more expressive than the for loop, and we can make it ourselves very easily without needing to wait for the language designers to add special syntactical constructs like <code>foreach</code> or <code>for of</code> loops:</p>
<pre><code class="lang-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">forEach</span><span class="hljs-params">(arr, fn)</span> </span>{
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) {
        fn(arr);
    }
}
<span class="hljs-comment">// arr.forEach can be used instead, but I'm reimplementing it for the sake of argument</span>
</code></pre>
<p>This shows why higher order functions are so important for expressive programming. They let you make abstractions like our forEach function that can abstract over behaviour, rather than just dealing with data structures. This means you have far more flexibility in the expressive constructs you use and you have access to a much wider variety of them without being limited by the syntactical constructs of the language. Any decent functional list library will have a range of functionality many times bigger than specialized list handling syntax can muster.</p>
<p>What this example also shows is that expressive programming is not just a characteristic of the language, it&#39;s an approach the programmer must take. This is especially true in JavaScript, where you have access to both high-level functional approaches and low-level C-ish constructs like loops and switch statements. And I would point to Scheme as a great example of a language that despite having few specialized features can be programmed very expressively (see SICP and the beautiful functions therein).</p>
<p>A good way to get used to this approach is to tackle problems in the following way:</p>
<ul>
<li>Determine an approach that will solve your problem in terms of simpler and more generic operations</li>
<li>Write that approach in a straightforward expressive way, even if it means using functions you don&#39;t have yet</li>
<li>Implement those functions the same way, writing them expressively in terms of smaller problems</li>
<li>Continue until all of the necessary functions are implemented<ul>
<li>In some cases, generic operations might need to use low-level approaches, like the <code>forEach</code> function above</li>
</ul>
</li>
</ul>
<p>Let&#39;s do an example. <a href="http://projecteuler.net/problem=3">Project Euler problem 3</a> asks for the largest prime factor of 600851475143. I&#39;ll use ES6 arrow functions for readability, but these are easily translatable into normal JS functions.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> projectEuler3 = () =&gt;
    <span class="hljs-built_in">Math</span>.max.apply(<span class="hljs-literal">null</span>, primeFactors(<span class="hljs-number">600851475143</span>));
</code></pre>
<p>So, we&#39;ve expressed exactly what we&#39;re looking for: the maximum element of the list of prime factors of 600851475143. Now, we need to implement primeFactors. Let&#39;s use the following algorithm:</p>
<ul>
<li>Find the first number from 2 to sqrt(x) that is a factor of x</li>
<li>If such a number exists, return that number, along with the prime factors of x divided by that number</li>
<li>Otherwise, return an array just with x (because x is prime)</li>
</ul>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> primeFactors = x =&gt; {
    <span class="hljs-keyword">var</span> factor = find(range(<span class="hljs-number">2</span>, <span class="hljs-built_in">Math</span>.floor(<span class="hljs-built_in">Math</span>.sqrt(x)) + <span class="hljs-number">1</span>),
        n =&gt; isFactor(n, x));
    <span class="hljs-keyword">return</span> factor !== <span class="hljs-literal">null</span> ?
        [factor].concat(primeFactors(x / factor)) :
        [x];
};
</code></pre>
<p>Again, really close to how we expressed the solution. But we used the functions <code>find</code>, <code>range</code>, and <code>isFactor</code>, so let&#39;s implement those. (The reason for adding one to the square root calculation is that range functions are generally inclusive on the lower bound and exclusive on the upper bound.)</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> isFactor = (a, b) =&gt; isInteger(b / a);

<span class="hljs-keyword">var</span> isInteger = x =&gt; x % <span class="hljs-number">1</span> === <span class="hljs-number">0</span>;
</code></pre>
<p>A number is a factor of another if the result of their division is an integer, and a number is an integer if the number modulo one is zero. Reads like a book, although in reality you certainly wouldn&#39;t constantly reimplement these.</p>
<p>Now we&#39;re down to more generic, simpler functions. Unfortunately, given the features JS provides, these have to be a bit more low-level. But they&#39;re still much shorter and easy to understand than the monolithic solutions you usually see for these kinds of problems. They&#39;re also generic enough to be gotten from libraries or put in a library and reused.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> find = (arr, pred) =&gt; {
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++)
        <span class="hljs-keyword">if</span> (pred(arr[i]))
            <span class="hljs-keyword">return</span> arr[i];
    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
};

<span class="hljs-keyword">var</span> range = (from, to) =&gt; {
    <span class="hljs-keyword">var</span> result = [];
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> n = from; n &lt; to; n++)
        result.push(n);
    <span class="hljs-keyword">return</span> result;
};
</code></pre>
<p>So here, we&#39;re using <code>for</code> loops to implement more the more abstract operations of finding the first element of a list that matches a predicate (a higher order function!) and getting a range of numbers. Any decent functional list library will provide similar functions, and <code>Array.prototype.find</code> is coming in ES6.</p>
<p><a href="http://www.es6fiddle.net/hu8fuftc/">And we&#39;re done!</a></p>
<p>So, this is how I see expressive programming. It&#39;s about coding your solutions as closely to the conceptual solutions as possible. This can be done with short, simple, pure functions and taking advantage of higher-order functions to make powerful, expressive abstractions. And it has many benefits:</p>
<ul>
<li>The problem-specific functions are short and easily understood </li>
<li>Little incidental complexity</li>
<li>Each function is easily testable and reusable</li>
<li>Understanding and writing each function has a low cognitive load</li>
<li>Low-level and difficult-to-read approaches are only used when really necessary</li>
<li>Allows for easy construction of <a href="http://mitpress.mit.edu/sicp/full-text/sicp/book/node29.html">abstraction barriers</a></li>
<li>No specific syntax needed</li>
</ul>
<p>So, as a JavaScript programmer, the features I am most excited about in ES6 are those that help with this goal, like arrow functions, which make functions easier to read and use, and the new HOFs coming to Array.prototype. Those are the features that really help expressive programming in JS, not limited syntactical additions.</p>

	<hr>
</div>
<div class="post">
	<h2><a href="/posts/2013-09-27-Functional-List-Processing-in-JS.html">Functional List Processing in JS</a></h2>
	<br>
	<span class="date-comments">September 27, 2013 | <a href="/posts/2013-09-27-Functional-List-Processing-in-JS.html#disqus_thread">Comments</a></span>
	<p>Many functional programming languages such as Scheme, Clojure and Haskell are heavily based on list processing, which has proved to be a useful approach for dealing with data and code alike. In particular, they tend to have a wide range of useful list processing functions that can simplify the use of lists while allowing them to replace constructs like loops. While JS doesn&#39;t share the elegance or theoretical purity of such languages, it took some cues from them in ES5 when the <code>map</code>, <code>reduce</code>, <code>reduceRight</code>, <code>some</code>, <code>every</code>, and <code>filter</code> functions were added to <code>Array.prototype</code>. These higher-order functions added flexibility, better scoping, and simplicity to programming techniques that were usually previously accomplished with <code>for</code> loops. JS is still lacking many of the useful features that functional languages use for creating and processing lists, but many of them can be implemented fairly easily in order to make it easier to use arrays and banish loops once and for all.</p>
<h3 id="-range-or-list-comprehensions-without-the-sugar"><code>range</code>, or list comprehensions without the sugar</h3>
<p>Languages like Python and CoffeeScript have <a href="http://en.wikipedia.org/wiki/List_comprehension">list comprehensions</a>: terse syntaxes for making lists with given ranges and constraints. However, I agree with the LISP philosophy that you shouldn&#39;t solve such simple problems by throwing more syntax at them - existing syntax should be used instead. For example, Clojure uses a couple of regular functions to do the same thing: whereas you could write <code>(i * 5 for i in [1..5])</code> in CoffeeScript, the equivalent Clojure would look like <code>(for [i (range 1 6)] (* i 5))</code>, which justs uses function calls and a binding form, maintaining syntactic simplicity. Well, the same approach can be applied in JavaScript with the following helper function:</p>
<pre><code class="lang-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">range</span><span class="hljs-params">(startOrEnd, end, step)</span> </span>{
    <span class="hljs-keyword">var</span> start;
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">arguments</span>.length &gt; <span class="hljs-number">1</span>) {
        start = startOrEnd;
    } <span class="hljs-keyword">else</span> {
        start = <span class="hljs-number">0</span>;
        end = startOrEnd;
    }
    step = step || <span class="hljs-number">1</span>;

    <span class="hljs-keyword">if</span> (step &gt; <span class="hljs-number">0</span> &amp;&amp; start &gt; end || step &lt; <span class="hljs-number">0</span> &amp;&amp; start &lt; end)
        <span class="hljs-keyword">return</span> [];

    <span class="hljs-keyword">var</span> result = [];
    <span class="hljs-keyword">if</span> (step &gt; <span class="hljs-number">0</span>)
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = start; i &lt; end; i += step)
            result.push(i);
    <span class="hljs-keyword">else</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = start; i &gt; end; i += step)
            result.push(i);
    <span class="hljs-keyword">return</span> result;
}
</code></pre>
<p>This function acts more or less the same way as <a href="http://clojuredocs.org/clojure_core/clojure.core/range">Clojure&#39;s range function</a>:</p>
<pre><code class="lang-javascript">range(<span class="hljs-number">5</span>); <span class="hljs-comment">// [0, 1, 2, 3, 4]</span>
range(-<span class="hljs-number">2</span>, <span class="hljs-number">3</span>); <span class="hljs-comment">// [-2, -1, 0, 1, 2]</span>
range(<span class="hljs-number">10</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>); <span class="hljs-comment">// [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]</span>
</code></pre>
<p>So, first of all, this pretty much replaces <code>for</code> loops. Instead of writing <code>for (var i = 0; i &lt; 10; i += 2) { ...</code>, you can write <code>range(0, 10, 2).forEach(function(i) { ...</code>, which is clearer in my opinion and carries other stylistic benefits. Also note that if you use <code>map</code> instead of <code>forEach</code>, you can get an array of results as well as getting the for loop behaviour, which can be very convenient and which brings us to our final goal of emulating list comprehensions:</p>
<pre><code class="lang-javascript">range(<span class="hljs-number">1</span>, <span class="hljs-number">6</span>).map(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(x)</span> </span>{ <span class="hljs-keyword">return</span> x * <span class="hljs-number">5</span>;}); <span class="hljs-comment">// Tadaa! [5, 10, 15, 20, 25]</span>
</code></pre>
<p>That&#39;s nice and useful, but not very pretty. Fortunately ES6 arrow functions will make it look much nicer. (ES6 also has list comprehensions, which I don&#39;t think are really necessary, but ES6 is proving to be a mish-mash of features anyway).</p>
<pre><code class="lang-javascript">range(<span class="hljs-number">1</span>, <span class="hljs-number">6</span>).map(x =&gt; x * <span class="hljs-number">5</span>); <span class="hljs-comment">// [5, 10, 15, 20, 25]</span>
</code></pre>
<p>And there you have it: the <code>for</code> loop and loop comprehension killer. You&#39;ll occasionally see hacks like <code>Array.apply(null, Array(10)).map(Number.call, Number)</code> to get a range on the fly, but you&#39;re much better off doing it properly with a helper function or using one from a library like Underscore.</p>
<p>More than any other function on this page, I&#39;d like to see this implemented as a native function, <code>Array.range</code> perhaps. It&#39;s really the last piece in the puzzle to making full use of <code>forEach</code>, <code>map</code>, etc.</p>
<h3 id="zipping-around">Zipping around</h3>
<pre><code class="lang-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">zipWith</span><span class="hljs-params">(fn)</span> </span>{
    <span class="hljs-keyword">var</span> arrays = <span class="hljs-built_in">Array</span>.prototype.slice.call(<span class="hljs-built_in">arguments</span>, <span class="hljs-number">1</span>);
    <span class="hljs-keyword">if</span> (arrays.length &lt; <span class="hljs-number">2</span>)
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'zip requires at least 2 arrays'</span>);

    <span class="hljs-keyword">var</span> length = arrays.slice(<span class="hljs-number">1</span>).reduce(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(minLength, arr)</span> </span>{
        <span class="hljs-keyword">return</span> arr.length &lt; minLength ? arr.length : minLength;
    }, arrays[<span class="hljs-number">0</span>].length);

    <span class="hljs-keyword">var</span> result = [];
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) {
        result.push(fn.apply(<span class="hljs-literal">null</span>, arrays.map(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(arr)</span> </span>{
            <span class="hljs-keyword">return</span> arr[i];
        })));
    }
    <span class="hljs-keyword">return</span> result;

    <span class="hljs-comment">/* 
     * If you have range(...), this last section could be expressed more cleanly as
     * return range(length).map(function(i) {
     *     return fn.apply(null, arrays.map(function(arr) {
     *         return arr[i];
     *     }));
     * });
     */</span>
}
</code></pre>
<p>This one is in Haskell and Clojure (as <code>map</code>). It takes a function as its first parameter and at least two arrays as subsequent parameters, then it returns an array of the results of calling the function with the array elements at the corresponding indices as arguments. So for example, if you called <code>zipWith(fn, arr1, arr2)</code>, it would return <code>[fn(arr1[0], arr2[0]), fn(arr1[1], arr2[1]), fn(arr1[2], arr2[2]), ...]</code>. <code>zipWith.apply(...)</code> is especially useful for working with matrices, but it has a range of other uses. Here are a couple of practical examples:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> arr1 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], arr2 = [<span class="hljs-number">6</span>, <span class="hljs-number">2</span>, -<span class="hljs-number">1</span>];

<span class="hljs-comment">// Sum the corresponding elements of the arrays</span>
zipWith(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(a, b)</span> </span>{ <span class="hljs-keyword">return</span> a + b; }, arr1, arr2); <span class="hljs-comment">// [7, 4, 2]</span>

<span class="hljs-comment">// Test if the arrays are equal</span>
zipWith(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(a, b)</span> </span>{ <span class="hljs-keyword">return</span> a === b; }, arr1, arr2).every(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(x)</span> </span>{ <span class="hljs-keyword">return</span> x; }); <span class="hljs-comment">// false</span>
</code></pre>
<p>And while we&#39;re talking about array equality,</p>
<h3 id="array-equality">Array equality</h3>
<p>When you&#39;re using arrays as your main data structure, you need to be able to check whether one array has the same values as another. There are good reasons for arrays to be treated as unique for comparison operators, but you <em>will</em> need an equation like this in order to do functional-style list processing. Note that this uses deep equality testing for arrays and shallow equality testing for other objects.</p>
<pre><code class="lang-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">arraysEqual</span><span class="hljs-params">(arr1, arr2)</span> </span>{
    <span class="hljs-keyword">if</span> (arr1.length != arr2.length)
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">if</span> (arr1 == <span class="hljs-literal">null</span> || arr2 == <span class="hljs-literal">null</span>)
        <span class="hljs-keyword">return</span> arr1 === arr2;

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; arr1.length; i++) {
        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Array</span>.isArray(arr1[i]) &amp;&amp; <span class="hljs-built_in">Array</span>.isArray(arr2[i])) {
            <span class="hljs-keyword">if</span> (!arraysEqual(arr1[i], arr2[i]))
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">if</span> (arr1[i] !== arr2[i])
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }
    }
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
}

arraysEqual([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]], [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]]); <span class="hljs-comment">// true</span>
arraysEqual([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>]], [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]); <span class="hljs-comment">// false</span>
</code></pre>
<h3 id="repetition">Repetition</h3>
<p><code>range</code> is by far the most useful list builder function, but sometimes it comes in handy to make a list that&#39;s just the same thing over and over again:</p>
<pre><code class="lang-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">repeat</span><span class="hljs-params">(times, value)</span> </span>{
    <span class="hljs-keyword">var</span> result = [];
    <span class="hljs-keyword">while</span> (times &gt; <span class="hljs-number">0</span>) {
        result.push(value);
        times--;
    }
    <span class="hljs-keyword">return</span> result;
}
</code></pre>
<p>And some examples:</p>
<pre><code class="lang-javascript"><span class="hljs-comment">// Multiplying a string</span>
<span class="hljs-keyword">var</span> googol = <span class="hljs-string">'1'</span> + repeat(<span class="hljs-number">100</span>, <span class="hljs-string">'0'</span>).join(<span class="hljs-string">''</span>);
<span class="hljs-comment">// "10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"</span>


<span class="hljs-comment">// Roll 10d6</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">rollDie</span><span class="hljs-params">(sides)</span> </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.floor(<span class="hljs-built_in">Math</span>.random() * sides) + <span class="hljs-number">1</span>;
}

repeat(<span class="hljs-number">10</span>, <span class="hljs-number">6</span>).map(rollDie).reduce(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(a, b)</span> </span>{ <span class="hljs-keyword">return</span> a + b; }); <span class="hljs-comment">// 38 (for example)</span>
</code></pre>
<h3 id="nesting-and-unnesting">Nesting and unnesting</h3>
<p>Last of all, it&#39;s often useful to deal with lists within lists, so here are a couple of functions for that. This first one returns a list split up into a sublists of a given length.</p>
<pre><code class="lang-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">partition</span><span class="hljs-params">(n, array)</span> </span>{
    <span class="hljs-keyword">var</span> result = [];
    <span class="hljs-keyword">var</span> length = <span class="hljs-built_in">Math</span>.floor(array.length / n);

    <span class="hljs-comment">// Again, range would make this part nicer</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) {
        result.push([]);
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) {
            result[i].push(array[n * i + j]);
        }
    }
    <span class="hljs-keyword">return</span> result;
}

partition(<span class="hljs-number">3</span>, range(<span class="hljs-number">9</span>)); <span class="hljs-comment">// [[0, 1, 2], [3, 4, 5], [6, 7, 8]]</span>

<span class="hljs-comment">// Make an empty 4*4 matrix</span>
partition(<span class="hljs-number">4</span>, repeat(<span class="hljs-number">16</span>, <span class="hljs-number">0</span>)); <span class="hljs-comment">// [[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]]</span>
</code></pre>
<p>And this takes a nested list and flattens it into a single layer.</p>
<pre><code class="lang-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">flatten</span><span class="hljs-params">(arr)</span> </span>{
    <span class="hljs-keyword">var</span> result = [];
    arr.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(el)</span> </span>{
        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Array</span>.isArray(el))
            result = result.concat(flatten(el)); <span class="hljs-comment">// w00t recursion</span>
        <span class="hljs-keyword">else</span>
            result.push(el);
    });
    <span class="hljs-keyword">return</span> result;
}

flatten([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, [[[<span class="hljs-number">5</span>]]]]]); <span class="hljs-comment">// [1, 2, 3, 4, 5]</span>

flatten(repeat(<span class="hljs-number">4</span>, range(<span class="hljs-number">2</span>))); <span class="hljs-comment">// [0, 1, 0, 1, 0, 1, 0, 1]</span>
</code></pre>
<h3 id="conclusion">Conclusion</h3>
<p>The point of these functions isn&#39;t just to make list processing a bit less wordy; they allow you to manipulate lists in a completely different way. Instead of dealing with lists in they way you generally see in the functions themselves - changing an index variable to represent the current element, pushing and changing arrays of results, etc. - you can express most list functions in a single statement, with no variable modifications whatsoever. Then, you can build up list operations and eventually entire programs by combining such functions into other functions, without having to mentally keep track of variables changing state. It takes some getting used to, but it&#39;s a great way to program.</p>
<p>Here&#39;s an example: the <a href="http://en.wikipedia.org/wiki/Vigen%C3%A8re_cipher">Vigenère cipher</a>. Basically, it&#39;s a Caesar cipher, but each letter is shifted by a different amount depending on a key, which if too short is repeated.</p>
<pre><code class="lang-javascript"><span class="hljs-comment">// Does modular addition of capital letters, e.g., Y + D = B</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">modAddCapsLetters</span><span class="hljs-params">(a, b)</span> </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">String</span>.fromCharCode((a.charCodeAt(<span class="hljs-number">0</span>) + b.charCodeAt(<span class="hljs-number">0</span>) - <span class="hljs-number">65</span> * <span class="hljs-number">2</span>) % <span class="hljs-number">26</span> + <span class="hljs-number">65</span>);
}

<span class="hljs-comment">// The imperative way</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">vigenereImp</span><span class="hljs-params">(str, key)</span> </span>{
    <span class="hljs-keyword">var</span> keyPos = <span class="hljs-number">0</span>, result = <span class="hljs-string">""</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; str.length; i++) {
        result += modAddCapsLetters(str.charAt(i), key[keyPos]));
        keyPos++;
        <span class="hljs-keyword">if</span> (keyPos &gt;= key.length)
            keyPos = <span class="hljs-number">0</span>;
    }
    <span class="hljs-keyword">return</span> result;
}

<span class="hljs-comment">// The functional way</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">vigenere</span><span class="hljs-params">(str, key)</span> </span>{
    <span class="hljs-keyword">var</span> keyRepeats = <span class="hljs-built_in">Math</span>.ceil(str.length / key.length),
        repeatedKey = flatten(repeat(keyRepeats, key.split(<span class="hljs-string">''</span>)));
    <span class="hljs-keyword">return</span> zipWith(modAddCapsLetters, str.split(<span class="hljs-string">''</span>), repeatedKey).join(<span class="hljs-string">''</span>);
}

vigenere(<span class="hljs-string">"LOOPSAREFORTHEWEAK"</span>, <span class="hljs-string">"LISPY"</span>);
<span class="hljs-comment">// "WWGEQLZWUMCBZTUPIC"</span>
</code></pre>
<p>So the imperative way does it step by step. It creates a variable <code>i</code> that increases for each letter, a variable <code>keyPos</code> that increases for each letter but gets reset to 0 once it&#39;s equal to the key length, and then shifts the letter in the input string by the given letter in the key. It concatenates each one to the end of a result string then returns it. Simple enough, but increases in complexity based on the amount of mutable data you have to keep track of. The functional way, instead, finds out how many times to repeat the key, creates a new array of letters with the key repeated the necessary amount, and then zips that with the original string using <code>modAddCapsLetters</code>. It&#39;s really a matter of preference, but I find the latter way of doing things conceptually simpler, and that helps a lot when building larger programs.</p>
<p>Check out Underscore or Lo-Dash for implementations of many of these functions.</p>

	<hr>
</div>
<div class="post">
	<h2><a href="/posts/2013-08-03-Evil-JS-With-Considered-Somewhat-Useful.html">Evil JS: With Considered Somewhat Useful</a></h2>
	<br>
	<span class="date-comments">August 3, 2013 | <a href="/posts/2013-08-03-Evil-JS-With-Considered-Somewhat-Useful.html#disqus_thread">Comments</a></span>
	<p><em>Note: Do not try this at work. It&#39;s not that bad but your coworkers and Douglas Crockford might get cross.</em></p>
<p><code>with</code> statements are a little-used, oft-reviled, and underappreciated part of JavaScript. Basically, they allow you to write a statement, often a block, with the properties of a given object added to the scope. Here&#39;s an example:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> x = <span class="hljs-built_in">Math</span>.cos(<span class="hljs-number">3</span>/<span class="hljs-number">2</span> * <span class="hljs-built_in">Math</span>.PI);

<span class="hljs-keyword">with</span>(<span class="hljs-built_in">Math</span>) {
    <span class="hljs-keyword">var</span> y = cos(<span class="hljs-number">3</span>/<span class="hljs-number">2</span> * PI);
}

x; <span class="hljs-comment">// -1</span>
y; <span class="hljs-comment">// -1</span>
</code></pre>
<p>The thing is, <code>with</code> statements are almost universally renounced in the JavaScript community. For example, you can read Douglas Crockford&#39;s attack on <code>with</code> from 2006 <a href="http://yuiblog.com/blog/2006/04/11/with-statement-considered-harmful/">here</a>. First of all, <code>with</code> can slow code down by making it difficult for the engine to know what variable is being referred to. But the main problem with <code>with</code> is that it complicates JS&#39;s notion of scope. Without <code>with</code>, the variables available in a scope are all of the global variables plus any variables made in local scopes using <code>var</code> or <code>function</code> statements. All of these variables can be both accessed and modified. But using <code>with</code> adds variables to the local scope that were not declared with a <code>var</code> or <code>function</code> statement and shadow those that were. Here&#39;s an example of the confusion that can be caused:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> obj = {
    a : <span class="hljs-number">1</span>,
    b : <span class="hljs-number">2</span>
};

<span class="hljs-keyword">with</span> (obj) {
    a = <span class="hljs-number">3</span>;
    <span class="hljs-keyword">var</span> b = <span class="hljs-number">4</span>;
    b = <span class="hljs-number">5</span>;
    c = <span class="hljs-number">6</span>;
}
</code></pre>
<p>Now, what are the values of <code>obj.a</code>, <code>obj.b</code>, <code>obj.c</code>, <code>a</code>, <code>b</code>, and <code>c</code>? ANSWER: <span class="spoiler"><code>obj</code> is <code>{a : 3, b : 5}</code>, <code>a</code> isn&#39;t defined, <code>b</code> is 4, and <code>c</code> is 6.</span></p>
<p>So there are good reasons to avoid <code>with</code>. In fact, ES5&#39;s strict mode prohibits its use. But the level of hatred and fear directed at it isn&#39;t proportional to its flaws and ignores the legitimate uses of with, which I&#39;ll cover now.</p>
<h3 id="libraries-and-modules">Libraries and Modules</h3>
<p>To use a library in JS, one generally has to constantly refer to its object when using its functions, for example using <code>jQuery.ajax</code> instead of <code>ajax</code>. This has led JS libraries to adopt short names such as <code>goog</code>, <code>_</code>, or <code>$</code> for somewhat easier typing, but with the costs of poor readability and losing useful short local variable names. Not adding the library functions to the scope is fine for libraries that you aren&#39;t using much, but can be inconvenient for libraries you&#39;re using heavily, which is why most programming languages provide a way to import the functions of a module into the current scope. Well, JS has one too:</p>
<pre><code class="lang-javascript"><span class="hljs-comment">// Returns a random angle in radians from a circle divided into the given number of steps</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">randomAngle</span><span class="hljs-params">(steps)</span> </span>{
    <span class="hljs-keyword">with</span>(<span class="hljs-built_in">Math</span>) {
        <span class="hljs-keyword">if</span> (!steps)
            <span class="hljs-keyword">return</span> random() * <span class="hljs-number">2</span> * PI;
        <span class="hljs-keyword">else</span>
            <span class="hljs-keyword">return</span> floor(random() * steps) / steps * <span class="hljs-number">2</span> * PI;
    }
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">randomAngle2</span><span class="hljs-params">(steps)</span> </span>{
    <span class="hljs-keyword">if</span> (!steps)
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.random() * <span class="hljs-number">2</span> * <span class="hljs-built_in">Math</span>.PI;
    <span class="hljs-keyword">else</span>
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.floor(<span class="hljs-built_in">Math</span>.random() * steps) / steps * <span class="hljs-number">2</span> * <span class="hljs-built_in">Math</span>.PI;
}
</code></pre>
<p>Yes, it&#39;s the same <code>Math</code> example. But it shows an important point: <code>with</code> can make dealing with libraries and built-in modules a lot easier. Unfortunately, with current attitudes towards <code>with</code>, we&#39;re stuck waiting until ES6 for a (hopefully) accepted way to do this.</p>
<h3 id="block-scope">Block Scope</h3>
<p>One oddity that makes JavaScript different from most C-style languages is the lack of block scope. Instead of local variables beings scoped to nearest block they&#39;re declared in (delimited by <code>{</code> and <code>}</code>), like in C or Java, JS variables are scoped to the nearest <code>function() {...}</code> in which they are declared. This is mostly fine (and in my opinion, not a problem at all if you use higher order array iterators), but can be occasionally problematic.</p>
<p>A common issue in asynchronous JS is using callbacks in a loop:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) {
    setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{ <span class="hljs-built_in">console</span>.log(i); }, <span class="hljs-number">10</span>);
}

<span class="hljs-comment">// From console:</span>
<span class="hljs-comment">// 5</span>
<span class="hljs-comment">// 5</span>
<span class="hljs-comment">// 5</span>
<span class="hljs-comment">// 5</span>
<span class="hljs-comment">// 5</span>
</code></pre>
<p>So, since the <code>for</code> loop finished executing before the callbacks were executed, the value of <code>i</code> is 5 every time.  In other languages, to get around this, you&#39;d just add a block-scoped variable for each iteration of the loop. In fact, this can be done right now in Firefox, but won&#39;t be standard until ES6 (see Solution 1 below). So, the standard solution is to wrap the whole thing in an <a href="http://en.wikipedia.org/wiki/IIFE">IIFE</a> (see Solution 2) which is widely supported, but adds a lot of visual noise. The other solution is to use <code>with</code> to emulate a block scope (Solution 3):</p>
<pre><code class="lang-javascript"><span class="hljs-comment">// Solution 1 - Elegant, but not widely supported</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) {
    <span class="hljs-keyword">let</span> j = i; <span class="hljs-comment">// A block scoped variable</span>
    setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{ <span class="hljs-built_in">console</span>.log(j); }, <span class="hljs-number">10</span>);
}

<span class="hljs-comment">// Solution 2 - Idiomatic but ugly</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) {
    (<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(j)</span> </span>{
        setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{ <span class="hljs-built_in">console</span>.log(j); }, <span class="hljs-number">10</span>);
    })(i);
}

<span class="hljs-comment">// Solution 3 - Widely supported and readable</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) {
    <span class="hljs-keyword">with</span> ({j : i})
        setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{ <span class="hljs-built_in">console</span>.log(j); }, <span class="hljs-number">10</span>);
}

<span class="hljs-comment">// From console:</span>
<span class="hljs-comment">// 0</span>
<span class="hljs-comment">// 1</span>
<span class="hljs-comment">// 2</span>
<span class="hljs-comment">// 3</span>
<span class="hljs-comment">// 4</span>
</code></pre>
<p>Basically, <code>with</code> lets you make block scoped variables. In fact, it&#39;s very similar to the <code>let</code> blocks that are coming in ES6:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> a;

<span class="hljs-keyword">let</span> (b = <span class="hljs-number">2</span>, c = <span class="hljs-number">3</span>) {
    a = b + c;
}

a; <span class="hljs-comment">// 5</span>

<span class="hljs-keyword">with</span> ({b : <span class="hljs-number">4</span>, c : <span class="hljs-number">7</span>}) {
    a = b + c;
}

a; <span class="hljs-comment">// 11</span>
</code></pre>
<p>So, while function scoped variables are usually adequate, <code>with</code> lets you use block scoping when you need it.</p>
<h3 id="summary">Summary</h3>
<h4 id="pros-">Pros:</h4>
<ul>
<li><code>with</code> makes it easier to work with libraries and modules.</li>
<li><code>with</code> allows you to clearly emulate block scope.</li>
<li>In general, using <code>with</code> sparingly can make your code easier to read and write.</li>
</ul>
<h4 id="cons-">Cons:</h4>
<ul>
<li>Using <code>with</code> poorly can result in unclear code.</li>
<li><code>with</code> is rejected by most linters and style guides.</li>
<li><code>with</code> can make code slower.</li>
<li>ES5 strict mode forbids the use of <code>with</code>.</li>
</ul>
<h3 id="conclusion">Conclusion</h3>
<p>I&#39;ve identified two cases where <code>with</code> can make for clearer code and emulate features that exist in most other languages. However, the JS community&#39;s aversion to <code>with</code> makes it almost unusable except in personal projects. Fortunately, both of its use cases will be replaced in ES6 by <code>let</code> and <code>import</code>, but for now, many coders are depriving themselves of a useful tool.So, don&#39;t use it at work, but if you have some hobby coding where readability is more important than speed, don&#39;t be too afraid to use <code>with</code>.</p>

	<hr>
</div>
<div class="post">
	<h2><a href="/posts/2013-06-22-JS-Object-Literal-Inheritance.html">JS Object Literal Inheritance</a></h2>
	<br>
	<span class="date-comments">June 22, 2013 | <a href="/posts/2013-06-22-JS-Object-Literal-Inheritance.html#disqus_thread">Comments</a></span>
	<p>A JavaScript question that often pops up is &quot;How do I set the prototype of an object literal?&quot; The short answer is that right now, you can&#39;t. When ES6 standardizes the <code>__proto__</code> property, you&#39;ll be able to do so directly, but right now, there&#39;s no native language construct. The good news is that it is downright simple to make a helper function that will let you use object literals in inheritance:</p>
<pre><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">extend</span><span class="hljs-params">(proto, literal)</span> </span>{
    <span class="hljs-keyword">var</span> result = <span class="hljs-built_in">Object</span>.create(proto);
    <span class="hljs-built_in">Object</span>.keys(literal).forEach(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(key)</span> </span>{
        result[key] = literal[key];
    });
    <span class="hljs-keyword">return</span> result;
}
</code></pre>
<p>You use it by calling it with the parent object as the first argument and the literal with the changes you want to make as the second: <code>var myObj = extend(parent, {foo : 2, bar : 3});</code> Here are some more examples:</p>
<pre><code class="lang-js"><span class="hljs-keyword">var</span> dog = {
    mammal : <span class="hljs-literal">true</span>,
    domestic : <span class="hljs-literal">true</span>,
    weight : <span class="hljs-number">50</span>,
    speak : <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-string">"woof"</span>;
    }
};

<span class="hljs-keyword">var</span> littleDog = extend(dog, {weight : <span class="hljs-number">10</span>});

littleDog.speak(); <span class="hljs-comment">// "woof"</span>
littleDog.weight; <span class="hljs-comment">// 10</span>

<span class="hljs-keyword">var</span> cat = extend(dog, {
    weight : <span class="hljs-number">12</span>,
    speak : <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-string">"meow"</span>;
    },
    breed : <span class="hljs-string">"siamese"</span>
});

cat.mammal; <span class="hljs-comment">// true</span>
cat.speak(); <span class="hljs-comment">// "meow"</span>
cat.breed; <span class="hljs-comment">// "siamese"</span>
</code></pre>
<p>So there you have it, an easy and useful construct for better differential inheritance. I&#39;m sure I&#39;m not the first person to use a function like this, and I bet you can find oodles of helper libraries that have something similar, but I think the ease with which you can make such an extension to JS&#39;s OOP model shows how awesome and flexible it is.</p>
<h5 id="notes-">Notes:</h5>
<ul>
<li><code>extend</code> requires ES5, or at least shims for <code>Object.create</code>, <code>Object.keys</code>, and <code>Array#forEach</code>. Here&#39;s a more complex ES3-compatible version:<pre><code class="lang-js"><span class="hljs-keyword">var</span> extend = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">F</span><span class="hljs-params">()</span></span>{}
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(proto, literal)</span> </span>{
      F.prototype = proto;
      <span class="hljs-keyword">var</span> result = <span class="hljs-keyword">new</span> F();
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> prop <span class="hljs-keyword">in</span> literal) {
          <span class="hljs-keyword">if</span> (literal.hasOwnProperty(prop)) {
              result[prop] = literal[prop];
          }
      }
      <span class="hljs-keyword">return</span> result;
  };
}();
</code></pre>
</li>
<li><code>Object.create</code> does take a second parameter that works in the same way as <code>extend</code>&#39;s, but it uses property descriptors rather than simple properties. So using it would look something like <code>var myObj = Object.create(parent, {foo : {configurable : true, writable : true, enumerable : true, value: 2}});</code>. A bit unwieldy.</li>
<li>Since <code>extend</code> copies the properties over from the object passed as the second parameter, you can use an existing object to specify the differences and it won&#39;t be modified.</li>
</ul>

	<hr>
</div>
<div class="post">
	<h2><a href="/posts/2013-06-16-Evil-JS-Macros.html">Evil JS: Macros</a></h2>
	<br>
	<span class="date-comments">June 16, 2013 | <a href="/posts/2013-06-16-Evil-JS-Macros.html#disqus_thread">Comments</a></span>
	<p><em>Note: Don&#39;t try this at work. This is bad code that shouldn&#39;t be used in production.</em></p>
<p>As every JS hacker knows, <code>eval</code> is evil. It&#39;s slow, insecure, and generally unnecessary. The same goes for the <code>Function</code> constructor, which can, but shouldn&#39;t be used to create functions using strings to specify the arguments and body. But the badness of <code>eval</code> and <code>Function</code> doesn&#39;t mean you can&#39;t have some fun with them.</p>
<p><code>Function.prototype.toString</code> is a function that returns the source code of the function it&#39;s called from. For example,</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> add = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(x, y)</span> </span>{
    <span class="hljs-keyword">return</span> x + y;
};

add.toString();
<span class="hljs-comment">/*
"function (x, y) {
    return x + y;
}"
*/</span>
</code></pre>
<p>This is a feature that is mostly used in debugging, but you&#39;ll note that since we can get the function as a string, we can modify it and pass it to the Function constructor. This allows us to implement a feature JS has been sorely lacking, C-style macros!</p>
<h3 id="simple-replacements">Simple Replacements</h3>
<p>So the first thing to implement is simple replacements, like #defines without arguments. Let&#39;s use an object to represent these definitions:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> defines = {
    PI : <span class="hljs-string">'3.14159'</span>,
    E : <span class="hljs-string">'2.71828'</span>,
    GREETING : <span class="hljs-string">'"Hello, "'</span>
};
</code></pre>
<p>And now we can implement the first version of the JS preprocesser (let&#39;s call it the JSPP). It takes a definition object and a function and returns another function with the macro expansion applied:</p>
<pre><code class="lang-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getBody</span><span class="hljs-params">(fn)</span> </span>{ <span class="hljs-comment">// Gets the body of a function as a string</span>
    fnStr = fn.toString();
    <span class="hljs-keyword">return</span> fnStr.slice(fnStr.indexOf(<span class="hljs-string">'{'</span>) + <span class="hljs-number">1</span>, fnStr.lastIndexOf(<span class="hljs-string">'}'</span>));
};

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getArgs</span><span class="hljs-params">(fn)</span> </span>{ <span class="hljs-comment">// Gets the arguments of a function as an array of strings</span>
    fnStr = fn.toString();
    <span class="hljs-keyword">return</span> fnStr.slice(fnStr.indexOf(<span class="hljs-string">'('</span>) + <span class="hljs-number">1</span>, fnStr.indexOf(<span class="hljs-string">')'</span>)).split(<span class="hljs-string">','</span>).map(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(x)</span> </span>{ <span class="hljs-keyword">return</span> x.trim(); });
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">JSPP</span><span class="hljs-params">(defines, fn)</span> </span>{
    <span class="hljs-keyword">var</span> args = getArgs(fn);

    <span class="hljs-comment">// Do the replacements</span>
    <span class="hljs-keyword">var</span> body = <span class="hljs-built_in">Object</span>.keys(defines)
        .reduce(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(text, replacement)</span> </span>{
            <span class="hljs-comment">// Uses a RegExp to ensure that the macro name has non-word characters on either side</span>
            <span class="hljs-comment">// Note that macro names should only use \w characters</span>
            <span class="hljs-keyword">return</span> text.replace(<span class="hljs-built_in">RegExp</span>(<span class="hljs-string">'(\\W+)'</span> + key + <span class="hljs-string">'(\\W+)'</span>, <span class="hljs-string">'g'</span>), <span class="hljs-string">'$1'</span> + defines[key] + <span class="hljs-string">'$2'</span>);
        }, getBody(fn));

    <span class="hljs-comment">// Use the function constructor to rebuild the function</span>
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Function</span>.apply(<span class="hljs-literal">null</span>, args.concat(body));
}
</code></pre>
<p>Example usage:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> defines = {
    PI : <span class="hljs-string">'3.14159'</span>,
    E : <span class="hljs-string">'2.71828'</span>,
    GREETING : <span class="hljs-string">'"Hello, "'</span>
};

<span class="hljs-keyword">var</span> doStuff = JSPP(defines, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(val)</span> </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> val === <span class="hljs-string">'number'</span> ? PI + E * val : GREETING + val;
});

doStuff(<span class="hljs-number">2</span>) <span class="hljs-comment">// 8.57815</span>
doStuff(<span class="hljs-string">'Bob'</span>) <span class="hljs-comment">// Hello, Bob</span>
doStuff.toString() <span class="hljs-comment">// function anonymous(val) { return typeof val === 'number' ? 3.14159 + 2.71828 * val : "Hello, " + val; }</span>
</code></pre>
<h3 id="function-like-macros">Function-like Macros</h3>
<p>Okay, let&#39;s go one level deeper: macro arguments. We&#39;ll use the same syntax as the <code>Function</code> constructor, argument strings followed by body, except in an array:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> defines = {
    ABS : [<span class="hljs-string">'x'</span>, <span class="hljs-string">'((x)&lt;0?-(x):(x))'</span>]
};
</code></pre>
<p>And the new (buggy) JSPP implementation:</p>
<pre><code class="lang-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getBody</span><span class="hljs-params">(fn)</span> </span>{ <span class="hljs-comment">// Gets the body of a function as a string</span>
    fnStr = fn.toString();
    <span class="hljs-keyword">return</span> fnStr.slice(fnStr.indexOf(<span class="hljs-string">'{'</span>) + <span class="hljs-number">1</span>, fnStr.lastIndexOf(<span class="hljs-string">'}'</span>));
};

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getArgs</span><span class="hljs-params">(fn)</span> </span>{ <span class="hljs-comment">// Gets the arguments of a function as an array of strings</span>
    fnStr = fn.toString();
    <span class="hljs-keyword">return</span> fnStr.slice(fnStr.indexOf(<span class="hljs-string">'('</span>) + <span class="hljs-number">1</span>, fnStr.indexOf(<span class="hljs-string">')'</span>)).split(<span class="hljs-string">','</span>).map(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(x)</span> </span>{ <span class="hljs-keyword">return</span> x.trim(); });
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">JSPP</span><span class="hljs-params">(defines, fn)</span> </span>{
    <span class="hljs-keyword">var</span> args = getArgs(fn);

    <span class="hljs-comment">// Do the replacements</span>
    <span class="hljs-keyword">var</span> body = <span class="hljs-built_in">Object</span>.keys(defines)
        .reduce(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(text, key)</span> </span>{
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> defines[key] === <span class="hljs-string">'string'</span>) { <span class="hljs-comment">// Do a simple replacement</span>
                <span class="hljs-keyword">return</span> text.replace(<span class="hljs-built_in">RegExp</span>(<span class="hljs-string">'(\\W+)'</span> + key + <span class="hljs-string">'(\\W+)'</span>, <span class="hljs-string">'g'</span>), <span class="hljs-string">'$1'</span> + defines[key] + <span class="hljs-string">'$2'</span>);
            } <span class="hljs-keyword">else</span> { <span class="hljs-comment">// Do a replacement with arguments</span>
                <span class="hljs-comment">// First, convert the arguments into regex replacement patterns, such as $1 or $23</span>
                <span class="hljs-keyword">var</span> macroBody = defines[key][defines[key].length - <span class="hljs-number">1</span>];
                <span class="hljs-keyword">var</span> macroArgs = defines[key].slice(<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>);
                <span class="hljs-keyword">var</span> replacement = macroArgs.reduce(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(text, arg, index)</span> </span>{
                    <span class="hljs-keyword">return</span> text.replace(<span class="hljs-built_in">RegExp</span>(arg, <span class="hljs-string">'g'</span>), <span class="hljs-string">'$'</span> + (index + <span class="hljs-number">1</span>));
                }, macroBody);
                <span class="hljs-comment">// Now, use RegExp capturing to apply the replacement</span>
                <span class="hljs-comment">// Note that macro names can't have regex metacharacters, macro arguments cannot have commas</span>
                <span class="hljs-comment">// and will often fail if they have ending parens, and there must be at least one argument.</span>
                <span class="hljs-comment">// This is a messy, bad, but easy way of doing the replacement,</span>
                <span class="hljs-comment">// which fits with the theme of the post, I feel.</span>
                <span class="hljs-keyword">return</span> text.replace(<span class="hljs-built_in">RegExp</span>(key + <span class="hljs-comment">// The macro name</span>
                                           <span class="hljs-string">'\\s*\\(\\s*(.+?)'</span> + <span class="hljs-comment">// The initial paren and first argument</span>
                                           <span class="hljs-built_in">Array</span>(macroArgs.length).join(<span class="hljs-string">'\\s*,\\s*(.+?)'</span>) + <span class="hljs-comment">// The other args, separated by commas</span>
                                           <span class="hljs-string">'\\s*\\)'</span>, <span class="hljs-comment">// The final paren</span>
                                           <span class="hljs-string">'g'</span>), replacement);
            }
        }, getBody(fn));
    <span class="hljs-comment">// Use the function constructor to rebuild the function</span>
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Function</span>.apply(<span class="hljs-literal">null</span>, args.concat(body));
}
</code></pre>
<p>Example usage:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> defines = {
    PI : <span class="hljs-string">'3.14159'</span>,
    E : <span class="hljs-string">'2.71828'</span>,
    ABS : [<span class="hljs-string">'x'</span>, <span class="hljs-string">'((x)&lt;0?-(x):(x))'</span>],
    RESISTORS_PARALLEL : [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'((a)*(b)/((a)+(b)))'</span>]
};

<span class="hljs-keyword">var</span> doStuff = JSPP(defines, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(val)</span> </span>{
    <span class="hljs-keyword">return</span> RESISTORS_PARALLEL(PI, E) * ABS(val);
});

doStuff(<span class="hljs-number">2</span>) <span class="hljs-comment">// 2.9146452959536644</span>
doStuff(-<span class="hljs-number">2</span>) <span class="hljs-comment">// 2.9146452959536644</span>
doStuff.toString()
<span class="hljs-comment">/*
function anonymous(val) {
    return ((3.14159)*(2.71828)/((3.14159)+(2.71828))) * ((val)&lt;0?-(val):(val));
}
*/</span>
</code></pre>
<p>So there you go, everyone&#39;s favourite preprocesser partially ported to JavaScript! And while this is not a good use of <code>Function</code> and <code>Function.prototype.toString</code>, it does show their power. They both have legitimate purposes, and if you&#39;re not afraid to go down that road, you can do some pretty wacky stuff with them.</p>

	<hr>
</div>
<div class="post">
	<h2><a href="/posts/2013-06-15-Hello,-World!.html">Hello, World!</a></h2>
	<br>
	<span class="date-comments">June 15, 2013 | <a href="/posts/2013-06-15-Hello,-World!.html#disqus_thread">Comments</a></span>
	<p>Good afternoon, Internet!</p>
<p>So I&#39;ve figured I need a place to store neat things I find in JS and other programming tricks. Hopefully someone else can benefit from them.</p>
<p>So, without further ado,</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> petStore = {};
petStore.birds = {
    <span class="hljs-string">'American Bushtit'</span> : <span class="hljs-string">'$98.99'</span>,
    <span class="hljs-string">'Antipodean Albatross'</span> : <span class="hljs-string">'$12.49'</span>,
    <span class="hljs-string">'Auckland Merganser'</span> : <span class="hljs-string">'$11.00'</span>,
    <span class="hljs-string">'Barn Owl'</span> : <span class="hljs-string">'$4.97'</span>,
    <span class="hljs-string">'Chestnut-crested Yuhina'</span> : <span class="hljs-string">'$25.00'</span>,
    <span class="hljs-string">'Chiriqui Yellowthroat'</span> : <span class="hljs-string">'$9.99'</span>,
    <span class="hljs-string">'Common Redpoll'</span> : <span class="hljs-string">'$5.50'</span>,
    <span class="hljs-string">'Common Yellowthroat'</span> : <span class="hljs-string">'$8.99'</span>,
    <span class="hljs-string">'Crested Drongo'</span> : <span class="hljs-string">'$12.50'</span>,
    <span class="hljs-string">'Crested Quetzal'</span> : <span class="hljs-string">'$44.99'</span>,
    <span class="hljs-string">'Dimorphic Egret'</span> : <span class="hljs-string">'$17.99'</span>,
    <span class="hljs-string">'Doherty\'s Bushshrike'</span> : <span class="hljs-string">'$10.05'</span>,
    <span class="hljs-string">'Dwarf Bittern'</span> : <span class="hljs-string">'$14.98'</span>,
};

<span class="hljs-built_in">console</span>.log(
    <span class="hljs-built_in">Object</span>
        .keys(petStore.birds)
        .sort(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(a,b)</span> </span>{ <span class="hljs-keyword">return</span> ((-<span class="hljs-string">'Bonjour, monde!'</span>.slice.call(petStore.birds[a],<span class="hljs-number">1</span>) &lt; -<span class="hljs-string">'Morning, all!'</span>.slice.call(petStore.birds[b],<span class="hljs-number">1</span>)) &lt;&lt; <span class="hljs-number">1</span>) - <span class="hljs-number">1</span> })
        .map(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(s)</span> </span>{ <span class="hljs-keyword">return</span> <span class="hljs-string">'What\'s up, bro!'</span>.replace.apply(s,[<span class="hljs-regexp">/[^A-Z]/g</span>,<span class="hljs-string">''</span>]) })
        .map(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(s)</span> </span>{ <span class="hljs-keyword">return</span> (<span class="hljs-string">'Howdy, y\'all!'</span>.charCodeAt.bind(s[<span class="hljs-number">0</span>])()-<span class="hljs-number">0101</span>)*<span class="hljs-number">032</span>+<span class="hljs-string">'Greetings, Earthlings!'</span>.charCodeAt.bind(s[<span class="hljs-number">1</span>])()-<span class="hljs-number">0101</span>;})
        .map(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(n)</span> </span>{ <span class="hljs-keyword">return</span> <span class="hljs-string">'Salutations, Earth!'</span>.constructor.fromCharCode(n+<span class="hljs-number">0x20</span>); })
        .join(<span class="hljs-string">'Adios, amigo'</span>.match()[<span class="hljs-number">0</span>])
);
</code></pre>

	<hr>
</div>
</div>
		</div>

		<script type="text/javascript" src="/main.js"></script>

		<!-- Disqus -->
		<script type="text/javascript">
		var disqus_shortname = 'j201';

		(function () {
		 var s = document.createElement('script'); s.async = true;
		 s.type = 'text/javascript';
		 s.src = '//' + disqus_shortname + '.disqus.com/count.js';
		 (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
		 }());
		</script>

		<!-- GA -->
		<script>
		(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
		(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
		m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
		})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

		ga('create', 'UA-41719393-1', 'auto');
		ga('send', 'pageview');

		</script>
	</body>
</html>
